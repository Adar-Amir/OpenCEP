Index: base/PatternStructure.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThese classes are used to represent a \"parameter\" to the PATTERN clause.\r\nThese classes represent a SEQ/AND/OR/KL operator and the atomic argument QItem.\r\nThe classes support nesting. Every operator class has its list of arguments.\r\nThe QItem class has an event type and its name. The name is referred to in\r\na pattern matching condition, represented as formula.\r\n\"\"\"\r\n\r\nfrom abc import ABC\r\nfrom typing import List\r\n\r\nclass PatternStructure(ABC):\r\n    def get_top_operator(self):\r\n        return type(self)\r\n\r\n    def get_args(self):\r\n        raise NotImplementedError()\r\n\r\n   # def remove_arg(self, pattern_struct: ABC):\r\n   #     raise NotImplementedError()\r\n\r\n    def duplicate(self):\r\n        raise NotImplementedError()\r\n\r\n    def copy(self):\r\n        raise NotImplementedError()\r\n\r\nclass QItem(PatternStructure):\r\n    def __init__(self, event_type: str, name: str):\r\n        #print(\"event:\", event_type)\r\n        #print(\"name:\", name)\r\n        self.event_type = event_type\r\n        self.name = name\r\n\r\n\r\nclass AndOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        self.args = args\r\n\r\n    def duplicate(self):\r\n        ret = AndOperator(list(self.args))\r\n        #ret.args = list(self.args)\r\n        return ret\r\n\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\nclass OrOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        self.args = args\r\n\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\n    def duplicate(self):\r\n        ret = OrOperator(list(self.args))\r\n        #ret.args = list(self.args)\r\n        return ret\r\n\r\nclass SeqOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        #for pattern in args:\r\n            #print(pattern)\r\n            #if isinstance(pattern, NegationOperator):\r\n                #args.remove(pattern)\r\n        #args = [arg for arg in args if not isinstance(arg, NegationOperator)]\r\n        self.args = args\r\n        \"\"\"print(\" \")\r\n        for pattern in args:\r\n            print(pattern.name)\"\"\"\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\n    def duplicate(self):\r\n        ret = SeqOperator(list(self.args))\r\n        #ret.args = list(self.args)\r\n        return ret\r\n\r\nclass KleeneClosureOperator(PatternStructure):\r\n    def __init__(self, arg: PatternStructure):\r\n        self.arg = arg\r\n\r\n\r\nclass NegationOperator(PatternStructure):\r\n    def __init__(self, arg: PatternStructure):\r\n        self.arg = arg\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- base/PatternStructure.py	(revision c0736428db09f818dcff6e290df9a8e43dd17a98)
+++ base/PatternStructure.py	(date 1589808523527)
@@ -94,3 +94,4 @@
     def __init__(self, arg: PatternStructure):
         self.arg = arg
 
+
Index: test/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nfrom CEP import CEP\r\nfrom evaluation.EvaluationMechanismFactory import EvaluationMechanismTypes, \\\r\n    IterativeImprovementEvaluationMechanismParameters\r\nfrom misc.IOUtils import file_input, file_output\r\nfrom misc.Stocks import MetastockDataFormatter\r\nfrom misc.Utils import generate_matches\r\nfrom evaluation.LeftDeepTreeBuilders import *\r\nfrom evaluation.BushyTreeBuilders import *\r\nfrom datetime import timedelta\r\nfrom base.Formula import GreaterThanFormula, SmallerThanFormula, SmallerThanEqFormula, GreaterThanEqFormula, MulTerm, EqFormula, IdentifierTerm, AtomicTerm, AndFormula, TrueFormula\r\nfrom base.PatternStructure import AndOperator, SeqOperator, QItem, NegationOperator\r\nfrom base.Pattern import Pattern\r\n\r\nnasdaqEventStreamShort = file_input(\"test/EventFiles/NASDAQ_SHORT.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamMedium = file_input(\"test/EventFiles/NASDAQ_MEDIUM.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamFrequencyTailored = file_input(\"test/EventFiles/NASDAQ_FREQUENCY_TAILORED.txt\", MetastockDataFormatter())\r\nnasdaqEventStream_AAPL_AMZN_GOOG = file_input(\"test/EventFiles/NASDAQ_AAPL_AMZN_GOOG.txt\", MetastockDataFormatter())\r\nnasdaqEventStream = file_input(\"test/EventFiles/NASDAQ_LONG.txt\", MetastockDataFormatter())\r\n\r\ndef closeFiles(file1, file2):\r\n    file1.close()\r\n    file2.close()\r\n\r\ndef fileCompare(pathA, pathB):\r\n    file1 = open(pathA)\r\n    file2 = open(pathB)\r\n    file1List = [] # List of unique patterns\r\n    file2List = [] # List of unique patterns\r\n    lineStack = \"\"\r\n    for line in file1:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file1List):\r\n            file1List.append(lineStack)\r\n            lineStack = \"\"\r\n    lineStack = \"\"\r\n    for line in file2:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file2List):\r\n            file2List.append(lineStack)\r\n            lineStack = \"\"\r\n    if len(file1List) != len(file2List): # Fast check\r\n        closeFiles(file1, file2)\r\n        return False\r\n    for line in file1List:\r\n        if not (line in file2List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    for line in file2List:\r\n        if not (line in file1List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    closeFiles(file1, file2)\r\n    return True\r\n\r\ndef createTest(testName, patterns, events=None):\r\n    if events == None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    pattern = patterns[0]\r\n    matches = generate_matches(pattern, events)\r\n    file_output(matches, '../TestsExpected/%sMatches.txt' % testName)\r\n    print(\"Finished creating test %s\" % testName)\r\n\r\n\r\ndef runTest(testName, patterns, createTestFile = False,\r\n            eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,\r\n            eval_mechanism_params = None, events = None):\r\n    if createTestFile:\r\n        createTest(testName, patterns, events)\r\n    if events is None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    cep = CEP(patterns, eval_mechanism_type, eval_mechanism_params)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    file_output(matches, '%sMatches.txt' % testName)\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % testName\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % testName\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (testName,\r\n          \"Succeeded\" if fileCompare(actual_matches_path, expected_matches_path) else \"Failed\", running_time))\r\n    os.remove(actual_matches_path)\r\n\r\ndef oneArgumentsearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\")]),\r\n        GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), AtomicTerm(135)),\r\n        timedelta.max\r\n    )\r\n    runTest(\"one\", [pattern], createTestFile)\r\n\r\ndef simplePatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\")]), \r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"simple\", [pattern], createTestFile)\r\n\r\ndef googleAscendPatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for a short ascend in the Google peak prices.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 3 minutes\r\n    \"\"\"\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('googleAscend', [googleAscendPattern], createTestFile)\r\n\r\ndef amazonInstablePatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for an in-stable day for Amazon.\r\n    PATTERN SEQ(AmazonStockPriceUpdate x1, AmazonStockPriceUpdate x2, AmazonStockPriceUpdate x3)\r\n    WHERE x1.LowestPrice <= 75 AND x2.PeakPrice >= 78 AND x3.LowestPrice <= x1.LowestPrice\r\n    WITHIN 1 day\r\n    \"\"\"\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]), IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    runTest('amazonInstable', [amazonInstablePattern], createTestFile)\r\n\r\ndef msftDrivRacePatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for a race between driv and microsoft in ten minutes\r\n    PATTERN SEQ(MicrosoftStockPriceUpdate a, DrivStockPriceUpdate b, MicrosoftStockPriceUpdate c, DrivStockPriceUpdate d, MicrosoftStockPriceUpdate e)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < d.PeakPrice AND d.PeakPrice < e.PeakPrice\r\n    WITHIN 10 minutes\r\n    \"\"\"\r\n    msftDrivRacePattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"MSFT\", \"c\"), QItem(\"DRIV\", \"d\"), QItem(\"MSFT\", \"e\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"e\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=10)\r\n    )\r\n    runTest('msftDrivRace', [msftDrivRacePattern], createTestFile)\r\n\r\ndef googleIncreasePatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This Pattern is looking for a 1% increase in the google stock in a half-hour.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b)\r\n    WHERE b.PeakPrice >= 1.01 * a.PeakPrice\r\n    WITHIN 30 minutes\r\n    \"\"\"\r\n    googleIncreasePattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\")]),\r\n        GreaterThanEqFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), MulTerm(AtomicTerm(1.01), IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))),\r\n        timedelta(minutes=30)\r\n    )\r\n    runTest('googleIncrease', [googleIncreasePattern], createTestFile)\r\n\r\ndef amazonSpecificPatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for an amazon stock in peak price of 73.\r\n    \"\"\"\r\n    amazonSpecificPattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"a\")]),\r\n        EqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73))\r\n    )\r\n    runTest('amazonSpecific', [amazonSpecificPattern], createTestFile)\r\n\r\ndef googleAmazonLowPatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for low prices of Amazon and Google at the same minute.\r\n    PATTERN AND(AmazonStockPriceUpdate a, GoogleStockPriceUpdate g)\r\n    WHERE a.PeakPrice <= 73 AND g.PeakPrice <= 525\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    googleAmazonLowPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"GOOG\", \"g\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73)),\r\n            SmallerThanEqFormula(IdentifierTerm(\"g\", lambda x: x[\"Peak Price\"]), AtomicTerm(525))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('googleAmazonLow', [googleAmazonLowPattern], createTestFile)\r\n\r\ndef nonsensePatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    This pattern is looking for something that does not make sense.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AvidStockPriceUpdate b, AppleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < a.PeakPrice\r\n    \"\"\"\r\n    nonsensePattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AVID\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('nonsense', [nonsensePattern], createTestFile)\r\n\r\ndef hierarchyPatternSearchTest(createTestFile = False):\r\n    \"\"\"\r\n    The following pattern is looking for Amazon < Apple < Google cases in one minute windows.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AppleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    hierarchyPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('hierarchy', [hierarchyPattern], createTestFile)\r\n\r\ndef multiplePatternSearchTest(createTestFile = False):\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]), IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('multiplePatterns', [amazonInstablePattern, googleAscendPattern], createTestFile)\r\n\r\ndef nonFrequencyPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]), \r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency\", [pattern], createTestFile)\r\n\r\ndef frequencyPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]), \r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"AMZN\": 442, \"LOCM\": 219})\r\n    runTest(\"frequency\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef arrivalRatesPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n    SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]), \r\n    AndFormula(\r\n        GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n        GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n    timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.ARRIVAL_RATES, [0.0159, 0.0153, 0.0076])\r\n    runTest(\"arrivalRates\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef nonFrequencyPatternSearch2Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]), \r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency2\", [pattern], createTestFile)\r\n\r\ndef frequencyPatternSearch2Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]), \r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])), \r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 2, \"AMZN\": 3, \"LOCM\": 1})\r\n    runTest(\"frequency2\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef nonFrequencyPatternSearch3Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency3\", [pattern], createTestFile)\r\n\r\ndef frequencyPatternSearch3Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"LOCM\": 219})\r\n    runTest(\"frequency3\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef nonFrequencyPatternSearch4Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency4\", [pattern], createTestFile)\r\n\r\ndef frequencyPatternSearch4Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AVID\": 1, \"LOCM\": 2, \"AAPL\": 3, \"AMZN\": 4})\r\n    runTest(\"frequency4\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef nonFrequencyPatternSearch5Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"), QItem(\"LOCM\", \"b3\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency5\", [pattern], createTestFile)\r\n\r\ndef frequencyPatternSearch5Test(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"), QItem(\"LOCM\", \"b3\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"LOCM\": 1, \"AAPL\": 2}) # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency5\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n    \r\ndef frequencyPatternSearch6Test(createTestFile = False):    \r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"), QItem(\"LOCM\", \"b3\")]), \r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 1, \"LOCM\": 2}) # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency6\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\ndef greedyPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('greedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.GREEDY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\ndef iiRandomPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\ndef iiRandom2PatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\ndef iiGreedyPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\ndef iiGreedy2PatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\ndef dpLdPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpLd1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\ndef dpBPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpB1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\ndef zStreamOrdPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream-ord1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ORDERED_ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\ndef zStreamPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]), IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0], [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\ndef frequencyTailoredPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    frequencyDict = {\"MSFT\": 256, \"DRIV\": 257, \"CBRL\": 1}\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, frequencyDict)\r\n    runTest('frequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\ndef nonFrequencyTailoredPatternSearchTest(createTestFile = False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]), IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    runTest('nonFrequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\ndef evaTest():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"APL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), QItem(\"GOOG\", \"c\")]),\r\n        GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"])),\r\n        timedelta.max\r\n    )\r\n\r\n    extraShortEventStream = file_input(\"test/EventFiles/Extra_Short.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    print('EVA_SUCCESS')\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    extraShort = 'extraShort'\r\n    file_output(matches, '%sMatches.txt' % extraShort)\r\n    ##expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % testName\r\n    ##actual_matches_path = \"test/Matches/%sMatches.txt\" % testName\r\n    ##print(\"Test %s result: %s, Time Passed: %s\" % (testName,\r\n     ##     \"Succeeded\" if fileCompare(actual_matches_path, expected_matches_path) else \"Failed\", running_time))\r\n    ##os.remove(actual_matches_path)\r\n\r\nevaTest()\r\n\r\noneArgumentsearchTest()\r\nsimplePatternSearchTest()\r\ngoogleAscendPatternSearchTest()\r\namazonInstablePatternSearchTest()\r\nmsftDrivRacePatternSearchTest()\r\ngoogleIncreasePatternSearchTest()\r\namazonSpecificPatternSearchTest()\r\ngoogleAmazonLowPatternSearchTest()\r\nnonsensePatternSearchTest()\r\nhierarchyPatternSearchTest()\r\nnonFrequencyPatternSearchTest()\r\narrivalRatesPatternSearchTest()\r\nfrequencyPatternSearchTest()\r\nnonFrequencyPatternSearch2Test()\r\nfrequencyPatternSearch2Test()\r\nnonFrequencyPatternSearch3Test()\r\nfrequencyPatternSearch3Test()\r\nnonFrequencyPatternSearch4Test()\r\nfrequencyPatternSearch4Test()\r\nnonFrequencyPatternSearch5Test()\r\nfrequencyPatternSearch5Test()\r\nfrequencyPatternSearch6Test()\r\ngreedyPatternSearchTest()\r\niiRandomPatternSearchTest()\r\niiRandom2PatternSearchTest()\r\niiGreedyPatternSearchTest()\r\niiGreedy2PatternSearchTest()\r\n#zStreamOrdPatternSearchTest()\r\n#zStreamPatternSearchTest()\r\ndpBPatternSearchTest()\r\ndpLdPatternSearchTest()\r\nnonFrequencyTailoredPatternSearchTest()\r\nfrequencyTailoredPatternSearchTest()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/tests.py	(revision c0736428db09f818dcff6e290df9a8e43dd17a98)
+++ test/tests.py	(date 1589809022708)
@@ -583,10 +583,10 @@
 
 def evaTest():
     pattern = Pattern(
-        SeqOperator([QItem("APL", "a"), NegationOperator(QItem("AMZN", "b")), QItem("GOOG", "c")]),
+        SeqOperator([QItem("AAPL", "a"), NegationOperator(QItem("AMZN", "b")), QItem("AMZN", "d"), QItem("GOOG", "c")]),
         GreaterThanFormula(IdentifierTerm("a", lambda x: x["Opening Price"]),
                                IdentifierTerm("c", lambda x: x["Opening Price"])),
-        timedelta.max
+        timedelta(minutes=7)
     )
 
     extraShortEventStream = file_input("test/EventFiles/Extra_Short.txt", MetastockDataFormatter())
@@ -606,7 +606,7 @@
     ##os.remove(actual_matches_path)
 
 evaTest()
-
+"""
 oneArgumentsearchTest()
 simplePatternSearchTest()
 googleAscendPatternSearchTest()
@@ -640,3 +640,4 @@
 dpLdPatternSearchTest()
 nonFrequencyTailoredPatternSearchTest()
 frequencyTailoredPatternSearchTest()
+"""
\ No newline at end of file
Index: CEP.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file contains the primary engine. It processes streams of events and detects pattern matches\r\nby invoking the rest of the system components.\r\n\"\"\"\r\nfrom misc.IOUtils import Stream\r\nfrom base.Pattern import Pattern\r\nfrom evaluation.EvaluationMechanismFactory import EvaluationMechanismParameters, \\\r\n    EvaluationMechanismTypes, EvaluationMechanismFactory\r\nfrom typing import List\r\nfrom datetime import datetime\r\n\r\n\r\nclass PerformanceSpecifications:\r\n    \"\"\"\r\n    A sketch of QoS specifications, we assume it will be an object constructed separately, and the\r\n    CEP engine will refer to it if it is passed.\r\n    Not implemented yet.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\nclass CEP:\r\n    \"\"\"\r\n    A CEP object contains a workload (list of patterns to be evaluated) and an evaluation mechanism.\r\n    The evaluation mechanism is created according to the parameters specified in the constructor.\r\n    \"\"\"\r\n    def __init__(self, patterns: List[Pattern],\r\n                 eval_mechanism_type: EvaluationMechanismTypes = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,\r\n                 eval_mechanism_params: EvaluationMechanismParameters = None,\r\n                 performance_specs: PerformanceSpecifications = None):#EVA_rajouter une possibilité de choisir le NegationMode\r\n        \"\"\"\r\n        Constructor of the class.\r\n        \"\"\"\r\n        if patterns is None:\r\n            raise Exception(\"No patterns are provided\")\r\n        if len(patterns) > 1:\r\n            raise NotImplementedError(\"Multi-pattern support is not yet available\")\r\n\r\n        #EVA ici séparer patterns[0] en un pattern avec tous les Positive events et un avec les negatifs.\r\n        #envoyer à la fonction juste les positifs\r\n\r\n        #test = patterns[0].structure.get_args()[0].name\r\n        NegationPostProcessing = True\r\n        if NegationPostProcessing:\r\n            PositifPattern = Pattern(patterns[0].positive_event, patterns[0].condition, patterns[0].window)\r\n\r\n        self.__eval_mechanism = EvaluationMechanismFactory.build_single_pattern_eval_mechanism(eval_mechanism_type,\r\n                                                                                               eval_mechanism_params,\r\n                                                                                               PositifPattern)\r\n        #Ici rajouter sur l'arbre créé les NegationNode pour Post-Processing Mode avec la Formula dans le InternalNode\r\n        #Pour le First-Chance Negation ???\r\n        self.__pattern_matches = None\r\n        self.__performance_specs = performance_specs\r\n\r\n    def run(self, event_stream: Stream):\r\n        \"\"\"\r\n        Applies the evaluation mechanism to detect the predefined patterns in a given stream of events.\r\n        Returns the total time elapsed during evaluation.\r\n        \"\"\"\r\n        self.__pattern_matches = Stream()\r\n        start = datetime.now()\r\n        self.__eval_mechanism.eval(event_stream, self.__pattern_matches)\r\n        return (datetime.now() - start).total_seconds()\r\n\r\n    def get_pattern_match(self):\r\n        \"\"\"\r\n        Returns one match from the output stream.\r\n        \"\"\"\r\n        if self.__pattern_matches is None:\r\n            return None\r\n        try:\r\n            return self.__pattern_matches.get_item()\r\n        except StopIteration:  # the stream might be closed.\r\n            return None\r\n\r\n    def get_pattern_match_stream(self):\r\n        \"\"\"\r\n        Returns the output stream containing the detected matches.\r\n        \"\"\"\r\n        return self.__pattern_matches\r\n\r\n    # For future support of dynamic workload modification\r\n    def add_pattern(self, pattern: Pattern, priority: int = 0):\r\n        raise NotImplementedError()\r\n\r\n    # For future support of dynamic workload modification\r\n    def remove_pattern(self, pattern: Pattern, priority: int = 0):\r\n        raise NotImplementedError()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- CEP.py	(revision c0736428db09f818dcff6e290df9a8e43dd17a98)
+++ CEP.py	(date 1589805452548)
@@ -46,7 +46,7 @@
 
         self.__eval_mechanism = EvaluationMechanismFactory.build_single_pattern_eval_mechanism(eval_mechanism_type,
                                                                                                eval_mechanism_params,
-                                                                                               PositifPattern)
+                                                                                               patterns[0])
         #Ici rajouter sur l'arbre créé les NegationNode pour Post-Processing Mode avec la Formula dans le InternalNode
         #Pour le First-Chance Negation ???
         self.__pattern_matches = None
Index: base/Pattern.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from base.Formula import Formula\r\nfrom base.PatternStructure import PatternStructure\r\nfrom datetime import timedelta\r\nfrom misc.StatisticsTypes import StatisticsTypes\r\n\r\nfrom base.Formula import GreaterThanFormula, SmallerThanFormula, SmallerThanEqFormula, GreaterThanEqFormula, MulTerm, EqFormula, IdentifierTerm, AtomicTerm, AndFormula, TrueFormula\r\nfrom base.PatternStructure import AndOperator, SeqOperator, QItem, NegationOperator\r\n\r\nclass Pattern:\r\n    \"\"\"\r\n    A pattern has several fields:\r\n    - a structure represented by a tree of operators over the primitive events (e.g., SEQ(A,B*, AND(C, NOT(D), E)));\r\n    - a condition to be satisfied by the primitive events (might consist of multiple nested conditions);\r\n    - a time window for the pattern matches to occur within.\r\n    A pattern can also carry statistics with it, in order to enable advanced\r\n    tree construction mechanisms - this is hopefully a temporary hack.\r\n    \"\"\"\r\n    def __init__(self, pattern_structure: PatternStructure, pattern_matching_condition: Formula = None,\r\n                 time_window: timedelta = timedelta.max):\r\n        self.structure = pattern_structure\r\n        self.condition = pattern_matching_condition\r\n        self.window = time_window\r\n        self.statistics_type = StatisticsTypes.NO_STATISTICS\r\n        self.statistics = None\r\n#EVA 17.05\r\n        self.positive_event = pattern_structure.duplicate()\r\n            #self.structure.get_top_operator()\r\n            #pattern_structure.duplicate()\r\n        self.negative_event = pattern_structure.duplicate()\r\n        i = 0\r\n        while i < len(pattern_structure.get_args()):\r\n            p = pattern_structure.get_args()[i]\r\n            if type(p) == NegationOperator:\r\n                self.positive_event.remove_arg(p)\r\n            else:\r\n                self.negative_event.remove_arg(p)\r\n            i += 1\r\n\r\n    def set_statistics(self, statistics_type: StatisticsTypes, statistics: object):\r\n        self.statistics_type = statistics_type\r\n        self.statistics = statistics\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- base/Pattern.py	(revision c0736428db09f818dcff6e290df9a8e43dd17a98)
+++ base/Pattern.py	(date 1589816625501)
@@ -23,9 +23,8 @@
         self.statistics_type = StatisticsTypes.NO_STATISTICS
         self.statistics = None
 #EVA 17.05
-        self.positive_event = pattern_structure.duplicate()
-            #self.structure.get_top_operator()
-            #pattern_structure.duplicate()
+
+        self.positive_event = S
         self.negative_event = pattern_structure.duplicate()
         i = 0
         while i < len(pattern_structure.get_args()):
@@ -39,3 +38,9 @@
     def set_statistics(self, statistics_type: StatisticsTypes, statistics: object):
         self.statistics_type = statistics_type
         self.statistics = statistics
+
+    #def split_Negation_Event(self):
+
+
+
+        #test = patterns[0].structure.get_args()[0].name
